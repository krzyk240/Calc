{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"sta",
				"static_cast"
			],
			[
				"io",
				"ios_base"
			],
			[
				"file",
				"file_name"
			],
			[
				"Ca",
				"Calckit"
			],
			[
				"A",
				"ARCHITECTURE"
			]
		]
	},
	"buffers":
	[
		{
			"file": "Makefile",
			"settings":
			{
				"buffer_size": 918,
				"line_ending": "Windows"
			}
		},
		{
			"file": "hoff.cpp",
			"settings":
			{
				"buffer_size": 2931,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"command_palette":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"console":
	{
		"height": 0.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/home/kwazar/Calc/kit.hoff",
		"/home/kwazar/Calc/kit",
		"/home/kwazar/Calc/kit.cpp",
		"/home/kwazar/Calc/lol.cpp.hoff",
		"/home/kwazar/Calc/lol.cpp",
		"/home/kwazar/Calc/Numeric-lib/Makefile",
		"/home/kwazar/Calc/makefile-var",
		"/home/kwazar/Calc/hoff.cpp",
		"/home/kwazar/Pulpit/kdevelop",
		"/home/kwazar/SFML/Makefile",
		"/home/kwazar/k/Makefile",
		"/home/kwazar/Pulpit/test.cpp",
		"/home/kwazar/Calc/Variable-lib/Makefile",
		"/home/kwazar/Calc/Main/Makefile",
		"/home/kwazar/Calc/Calckit/Makefile",
		"/home/kwazar/Calc/Calckit/funkcje-k.cpp",
		"/home/kwazar/Calc/Numeric-lib/funkcje-v.cpp",
		"/home/kwazar/Calc/Numeric-lib/funkcje-d.cpp",
		"/home/kwazar/Calc/Main/spis.hpp",
		"/home/kwazar/Calc/Main/main.cpp",
		"/home/kwazar/Calc/Variable-lib/var_base.hpp",
		"/home/kwazar/Calc/Variable-lib/var_base.cpp",
		"/home/kwazar/SFML/src/SFML/Makefile",
		"/home/kwazar/Calc/clean",
		"/home/kwazar/k/kit.c",
		"/home/kwazar/Calc/main/lol/Makefile",
		"/home/kwazar/src/codeblocks/Makefile.am",
		"/home/kwazar/SFML/src/SFML/Audio/Makefile",
		"/home/kwazar/SFML/CMakeLists.txt",
		"/home/kwazar/Calc/README.md",
		"/home/kwazar/Calc/funkcje-d.cpp",
		"/home/kwazar/Calc/Makefile",
		"/home/kwazar/Calc/funkcje-k.cpp",
		"/home/kwazar/Calc/calckit/funkcje-k.cpp",
		"/home/kwazar/Calc/spis.hpp",
		"/home/kwazar/Calc/main.cpp",
		"/home/kwazar/Calc/funkcje-v.cpp",
		"/home/kwazar/Calc/var_base.cpp",
		"/home/kwazar/Calc/var_base.hpp",
		"/home/kwazar/Calc/.git/logs/HEAD",
		"/usr/bin/kdevelop",
		"/home/kwazar/src/reinstall-kdevelop",
		"/home/kwazar/src/update-kdevelop",
		"/home/kwazar/.kde/share/apps/kdevelop/sessions/{d886f093-6801-4ab6-8486-8cd32ecd45a6}/lock",
		"/home/kwazar/lol",
		"/home/kwazar/Calc2.4/obj/Linux/32bit/funkcje-k.rpo",
		"/etc/gnome/menus.blacklist",
		"/usr/share/applications/mimeinfo.cache",
		"/usr/include/c++/4.7.3/iostream",
		"/usr/include/c++/4.7.3/ostream",
		"/usr/include/c++/4.7.3/ios",
		"/usr/include/c++/4.7.3/iosfwd",
		"/usr/include/c++/4.7.3/bits/basic_ios.h",
		"/usr/include/c++/4.7.3/bits/basic_ios.tcc",
		"/usr/include/c++/4.7.3/bits/ios_base.h",
		"/home/kwazar/.config/sublime-text-3/Packages/Default/Preferences.sublime-settings",
		"/home/kwazar/.config/sublime-text-3/Packages/User/Preferences.sublime-settings"
	],
	"find":
	{
		"height": 35.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"00",
			"4e",
			"#ifndef spis_hpp\n#define spis_hpp\n/*\n__builtin_ctz - podaje numer najmłodszego zapalonego bitu (skrót od count trailing zeros)\n\n__builtin_clz - podaje ilość zer wiodących, co po odjęciu od długości reprezentacji (32 lub 64 bity), daje nam pozycję najstarszego zapalonego bitu (skrót od count leading zeros)\n\n__builtin_popcount - podaje ilość zapalonych bitów liczby\n*/\n\n#include <vector>\n#include <iostream>\n\nconst int BASE=1000000000, L=9;\n\nenum color{_yellow, _blue, _red, _green, _default};\n\nusing namespace std;\n\n#ifdef WIN32\n\n#include <windows.h>\n\n#define color_yellow SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY)\n#define color_blue SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY)\n#define color_red SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_RED | FOREGROUND_INTENSITY)\n#define color_green SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_GREEN | FOREGROUND_INTENSITY)\n#define color_default SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_RED)\ninline void hide_file()\n{system(\"attrib +h .kalk_config.cfg\");}\ninline void nhide_file()\n{system(\"attrib -h .kalk_config.cfg\");}\n\n#else\n\n#define color_yellow cout << \"\\033[01;33m\"\n#define color_blue cout << \"\\033[01;34m\"\n#define color_red cout << \"\\033[01;31m\"\n#define color_green cout << \"\\033[01;32m\"\n#define color_default cout << \"\\033[00m\"\ninline void hide_file()\n{;}\ninline void nhide_file()\n{;}\n\n//main.cpp\nint getch();\n\n#endif\n\n//funkcje-v.cpp\n//void czytaj(vector<int> &a);\nvoid wypisz(vector<int> a);\nvoid kas0(vector<int> &a);\nvector<int> operator+(vector<int> a, vector<int> b);\nvoid operator+=(vector<int> &a, vector<int> b);\nvector<int> operator-(vector<int> a, vector<int> b);\nvoid operator-=(vector<int> &a, vector<int> b);\nvector<int> operator*(vector<int> a, int b);\nvoid operator*=(vector<int> &a, int b);\nvector<int> operator*(vector<int> a, vector<int> b);\nvoid operator*=(vector<int> &a, vector<int> b);\nvector<int> operator/(vector<int> a, vector<int> b);\nvoid operator/=(vector<int> &a, vector<int> b);\nvector<int> operator%(vector<int> a, vector<int> b);\nvoid operator%=(vector<int> &a, vector<int> b);\nvector<int> operator^(vector<int> a, vector<int> b);\nvoid operator^=(vector<int> &a, vector<int> b);\nbool operator<(vector<int> a, vector<int> b);\nbool operator>(vector<int> a, vector<int> b);\nbool operator==(vector<int> a, vector<int> b);\nbool operator>=(vector<int> a, vector<int> b);\nbool operator<=(vector<int> a, vector<int> b);\nbool operator!=(vector<int> a, vector<int> b);\nvector<int> nwd(vector<int> a, vector<int> b);\nvoid nwdp(vector<int> a, vector<int> b, vector<int> &k);\nint logcal(vector<int> a);\n\n//funkcje-d.cpp\nstruct dn\n{\n	vector<int> l, m;\n	bool z;//true - dodatnia\n	~dn(){vector<int>().swap(l);vector<int>().swap(m);}\n};\n//void czytaj(dn &a);\nvoid wypisz(dn a, bool *outp);\ndn operator+(dn a, dn b);\nvoid operator+=(dn &a, dn b);\ndn operator-(dn a, dn b);\nvoid operator-=(dn &a, dn b);\ndn operator*(dn a, dn b);\nvoid operator*=(dn &a, dn b);\nvoid fft_fast(vector<int> &a, vector<int> &b);\ndn operator/(dn a, dn b);\nvoid operator/=(dn &a, dn b);\ndn operator%(dn a, dn b);\nvoid operator%=(dn &a, dn b);\ndn operator^(dn a, dn b);\nvoid operator^=(dn &a, dn b);\nbool operator>(dn a, dn b);\nbool operator<(dn a, dn b);\nbool operator==(dn a, dn b);\nbool operator>=(dn a, dn b);\nbool operator<=(dn a, dn b);\nbool operator!=(dn a, dn b);\ndn logc(dn a);\nvoid factorial(dn &a);\nbool isnERR();\n\n//funkcje-k.cpp\nvoid opp(dn &a);\nbool don(string &s, int begin, int end);\ndn zmien(string &s, int lp, int lk);\nint pri(char a);\nvoid dzial(vector<dn> &a, vector<bool> &mi, vector<char> &z, int &in, char znak);\nstring f_pos_to_str(int p, int k, string &s);\nbool oper(string s, int start, int end);\n\n//main.cpp\nstring to_string(int a);\nvoid mcol(color c);\nvoid help();\nvoid scol();\nvoid settings();\nvoid buffer(string &w);\nvoid convert(string &w);\nbool identyfity(string &s);\n\n#endif // spis_hpp\n\n#ifndef var_base_hpp\n#define var_base_hpp\n\n#include <queue>\n#include <string>\n#include <stack>\n\nusing namespace std;\n\nnamespace var_base\n{\n	struct ver\n	{\n		int t[256];\n		dn w;\n		bool is;\n		ver();\n		~ver(){};\n	};\n	extern vector<ver> _v;\n	extern queue<int> _free;\n	extern bool is_there;\n	void add_var(string s, dn w);\n	bool remove_var(string s);\n	bool read_var(string s, dn &w);\n}\n\n#endif // var_base_hpp\n\n\nnamespace var_base\n{\n	ver::ver(): is(false)\n	{\n		for(short int i=0; i<256; i++)\n			t[i]=0;\n	}\n	vector<ver> _v(1);\n	queue<int> _free;\n	bool is_there;\n\n	void add_var(string s, dn w)\n	{\n		ver x;\n		int k=0, sl=s.size();\n		for(int i=0; i<sl; i++)\n		{\n			if(_v[k].t[static_cast<int>(s[i])]==0)\n			{\n				if(_free.empty())\n				{\n					_v[k].t[static_cast<int>(s[i])]=_v.size();\n					k=_v.size();\n					_v.push_back(x);\n				}\n				else\n				{\n					_v[k].t[static_cast<int>(s[i])]=_free.front();\n					k=_free.front();\n					_v[k]=x;\n					_free.pop();\n				}\n			}\n			else k=_v[k].t[static_cast<int>(s[i])];\n		}\n		_v[k].is=true;\n		vector<int>().swap(_v[k].w.l);\n		vector<int>().swap(_v[k].w.m);\n		_v[k].w.l.swap(w.l);\n		_v[k].w.m.swap(w.m);\n		_v[k].w.z=w.z;\n	}\n\n	bool remove_var(string s)\n	{\n		int k=0, sl=s.size();\n		stack<int> grt;\n		grt.push(0);\n		for(int i=0; i<sl; i++)\n		{\n			if(_v[k].t[static_cast<int>(s[i])]==0) return 0;\n			else\n			{\n				k=_v[k].t[static_cast<int>(s[i])];\n				grt.push(k);\n			}\n		}\n		if(!_v[k].is) return 0;\n		_v[k].is=false;\n		while(grt.size()>1)\n		{\n			sl--;\n			for(short int i=0; i<256; i++)\n				if(_v[k].t[i]!=0) return 1;\n			grt.pop();\n			_free.push(k);\n			k=grt.top();\n			_v[k].t[static_cast<int>(s[sl])]=0;\n		}\n	return 1;\n	}\n\n	bool read_var(string s, dn &w)\n	{\n		int k=0, sl=s.size();\n		for(int i=0; i<sl; i++)\n		{\n			if(_v[k].t[static_cast<int>(s[i])]==0) return 0;\n			else k=_v[k].t[static_cast<int>(s[i])];\n		}\n		if(!_v[k].is) return 0;\n		w=_v[k].w;\n	return 1;\n	}\n}\n\n#include <fstream>\n\nbool _color=1, output[]={0,0,1,1};\n\nstring to_string(int a)\n{\n	string c, b;\n	if(a<0){a=-a;b+='-';}\n	while(a>0)\n	{\n		c+=a%10+48;\n		a/=10;\n	}\n	for(int i=c.size()-1; i>=0; i--)\n		b+=c[i];\n	if(b.size()==0) b=\"0\";\nreturn b;\n}\n\nvoid mcol(color c)\n{\n	if(!_color) return;\n	if(c==_yellow) color_yellow;\n	else if(c==_blue) color_blue;\n	else if(c==_red) color_red;\n	else if(c==_green) color_green;\n	else if(c==_default) color_default;\n}\n\nvoid help()\n{\n	mcol(_default);\n	cout << \"----------------------------------------------\\nCommand list:\\ncol-off - switch off synax highlighting\\ncol-on - switch on synax highlighting\\nexit - quit\\nhelp - this\\nsettings - outputing settings\\n----------------------------------------------\\n\";\n}\n\nvoid scol()\n{\n	fstream kalk_conf_file;\n	nhide_file();\n	kalk_conf_file.open(\".kalk_config.cfg\", ios::out);\n	if(kalk_conf_file.good()) kalk_conf_file << output[0] << output[1] << output[2] << output[3] << _color;\n	kalk_conf_file.close();\n	hide_file();\n}\n\n//___________________________________________________\n#ifdef WIN32\n\n#include <conio.h>\n\nvoid settings()\n{\n	mcol(_default);\n	cout << \"----------------------------------------------\\n\";\n	cout << \"1. Writing: Fraction (improper):  \" << (output[0]?'Y':'N') << \"\\n\";\n	cout << \"2. Writing: Mixed numeral:        \" << (output[1]?'Y':'N') << \"\\n\";\n	cout << \"3. Writing: Repeating decimal:    \" << (output[2]?'Y':'N') << \"\\n\";\n	cout << \"4. Writing: Scientific notation:  \" << (output[3]?'Y':'N') << \"\\n\";\n	cout << \"5. Writing: Synax highlighting:   \" << (_color?'Y':'N') << \"\\n\";\n	cout << \"Edyting option: put number (r - return): \";\n	char z=getch();\n	while(z!='r')\n	{\n		if(z<49 || z>53){cout << \"\\nWrong number!\";getch();}\n		else\n		{\n			cout << \"\\nNew value (y - yes, n - no): \";\n			char o=getch();\n			if(o=='y' || o=='Y')\n			{\n				if(z=='5') _color=1;\n				else output[z-49]=1;\n			}\n			else if(o=='n' || o=='N')\n			{\n				if(z=='5') _color=0;\n				else output[z-49]=0;\n			}\n		}\n		cout << \"\\n----------------------------------------------\\n\";\n		cout << \"1. Writing: Fraction (improper):  \" << (output[0]?'Y':'N') << \"\\n\";\n		cout << \"2. Writing: Mixed numeral:        \" << (output[1]?'Y':'N') << \"\\n\";\n		cout << \"3. Writing: Repeating decimal:    \" << (output[2]?'Y':'N') << \"\\n\";\n		cout << \"4. Writing: Scientific notation:  \" << (output[3]?'Y':'N') << \"\\n\";\n		cout << \"5. Writing: Synax highlighting:   \" << (_color?'Y':'N') << \"\\n\";\n		cout << \"Edyting option: put number (r - return): \";\n		z=getch();\n	}\n	cout << \"\\n----------------------------------------------\\n\";\n	fstream kalk_conf_file;\n	nhide_file();\n	kalk_conf_file.open(\".kalk_config.cfg\", ios::out);\n	if(kalk_conf_file.good()) kalk_conf_file << output[0] << output[1] << output[2] << output[3] << _color;\n	kalk_conf_file.close();\n	hide_file();\n}\n\nvoid buffer(string &w)\n{\n	w=\"\";\n	char z=cin.get();\n	while(z!=10)\n	{\n		w+=z;\n		z=cin.get();\n	}\n}\n\n#else\n\n#include <sys/ioctl.h>\n#include <termios.h>\n#include <unistd.h>\n#include <cstdio>\n#include <cstring>\n\nvoid settings()\n{\n	mcol(_default);\n	cout << \"----------------------------------------------\\n\";\n	cout << \"1. Writing: Fraction (improper):  \" << (output[0]?'Y':'N') << \"\\n\";\n	cout << \"2. Writing: Mixed numeral:        \" << (output[1]?'Y':'N') << \"\\n\";\n	cout << \"3. Writing: Repeating decimal:    \" << (output[2]?'Y':'N') << \"\\n\";\n	cout << \"4. Writing: Scientific notation:  \" << (output[3]?'Y':'N') << \"\\n\";\n	cout << \"5. Writing: Synax highlighting:   \" << (_color?'Y':'N') << \"\\n\";\n	cout << \"Edyting option: put number (r - return): \";\n	char z=getch();\n	while(z!='r')\n	{\n		if(z<49 || z>53){cout << \"\\033[G\\033[2KWrong number!\";getch();}\n		else\n		{\n			cout << \"\\033[G\\033[2KNew value (y - yes, n - no): \";\n			char o=getch();\n			if(o=='y' || o=='Y')\n			{\n				if(z=='5') _color=1;\n				else output[z-49]=1;\n			}\n			else if(o=='n' || o=='N')\n			{\n				if(z=='5') _color=0;\n				else output[z-49]=0;\n			}\n		}\n		cout << \"\\033[2K\\033[F\\033[2K\\033[F\\033[2K\\033[F\\033[2K\\033[F\\033[2K\\033[F\\033[2K\\033[F\";\n		cout << \"----------------------------------------------\\n\";\n		cout << \"1. Writing: Fraction (improper):  \" << (output[0]?'Y':'N') << \"\\n\";\n		cout << \"2. Writing: Mixed numeral:        \" << (output[1]?'Y':'N') << \"\\n\";\n		cout << \"3. Writing: Repeating decimal:    \" << (output[2]?'Y':'N') << \"\\n\";\n		cout << \"4. Writing: Scientific notation:  \" << (output[3]?'Y':'N') << \"\\n\";\n		cout << \"5. Writing: Synax highlighting:   \" << (_color?'Y':'N') << \"\\n\";\n		cout << \"Edyting option: put number (r - return): \";\n		z=getch();\n	}\n	cout << \"\\033[G\\033[2K----------------------------------------------\\n\";\n	fstream kalk_conf_file;\n	nhide_file();\n	kalk_conf_file.open(\".kalk_config.cfg\", ios::out);\n	if(kalk_conf_file.good()) kalk_conf_file << output[0] << output[1] << output[2] << output[3] << _color;\n	kalk_conf_file.close();\n	hide_file();\n}\n\nint kbhit(void)\n{\n	struct termios term, oterm;\n	int fd=0;\n	int c=0;\n	tcgetattr(fd, &oterm);\n	memcpy(&term, &oterm, sizeof(term));\n	term.c_lflag=term.c_lflag & (!ICANON);\n	term.c_cc[VMIN]=0;\n	tcsetattr(fd, TCSANOW, &term);\n	c=getchar();\n	tcsetattr(fd, TCSANOW, &oterm);\n	if(c!=-1)\n	ungetc(c, stdin);\nreturn ((c!=-1) ? 1:0);\n}\n\nint getch()\n{\n	static int ch = -1, fd = 0;\n	struct termios neu, alt;\n	fd = fileno(stdin);\n	tcgetattr(fd, &alt);\n	neu = alt;\n	neu.c_lflag &= ~(ICANON|ECHO);\n	tcsetattr(fd, TCSANOW, &neu);\n	ch = getchar();\n	tcsetattr(fd, TCSANOW, &alt);\n	return ch;\n}\n\nint getmaxx()\n{\n	int x=0;\n	#ifdef TIOCGSIZE\n	struct ttysize ts;\n	ioctl(STDIN_FILENO, TIOCGSIZE, &ts);\n	x=ts.ts_cols;\n	#elif defined(TIOCGWINSZ)\n	struct winsize ts;\n	ioctl(STDIN_FILENO, TIOCGWINSZ, &ts);\n	x=ts.ws_col;\n	#endif /* TIOCGSIZE */\nreturn x;\n}\n\nint getmaxy()\n{\n	int y=0;\n	#ifdef TIOCGSIZE\n	struct ttysize ts;\n	ioctl(STDIN_FILENO, TIOCGSIZE, &ts);\n	y=ts.ts_lines;\n	#elif defined(TIOCGWINSZ)\n	struct winsize ts;\n	ioctl(STDIN_FILENO, TIOCGWINSZ, &ts);\n	y=ts.ws_row;\n	#endif /* TIOCGSIZE */\nreturn y;\n}\n\nvector<string> name_base;\n\nvoid buffer(string &w)\n{\n	vector<string> v=name_base;\n	int poz=0, qy=name_base.size();\n	string k;\n	name_base.push_back(k);\n	char KEY_UP[]={27,91,65,'\\0'}, KEY_DOWN[]={27,91,66,'\\0'}, KEY_LEFT[]={27,91,68,'\\0'}, KEY_RIGHT[]={27,91,67,'\\0'}, DELETE[]={27,91,51,126,'\\0'}, BACKSPACE[]={127,'\\0'};\n	int width=getmaxx();\n	char z=getch();\n	while(1)\n	{\n		k=\"\";\n		k+=z;\n		while(kbhit())\n		{\n			z=getch();\n			k+=z;\n		}\n		if(k==BACKSPACE)\n		{\n			if(poz>0)\n			{\n				name_base[qy].erase(poz-1,1);\n				/******* KEY_LEFT *******/\n				if(poz%width==0)\n				{\n					cout << KEY_UP;\n					for(int i=0; i<width; i++)\n					{\n						cout << KEY_RIGHT;\n					}\n				}\n				else cout << KEY_LEFT;\n				poz--;\n				/******* END *******/\n				int r=poz;\n				for(; r<signed(name_base[qy].size()); r++)\n					cout << name_base[qy][r];\n				r++;\n				cout << \" \";\n				if(r%width==0) cout << \"\\033[E\";\n				for(; r>poz; r--)\n				{\n					if(r%width==0)\n					{\n						cout << KEY_UP;\n						for(int i=0; i<width; i++)\n						{\n							cout << KEY_RIGHT;\n						}\n					}\n					else cout << KEY_LEFT;\n				}\n			}\n		}\n		else if(k==DELETE)\n		{\n			if(poz<signed(name_base[qy].size()))\n			{\n				name_base[qy].erase(poz,1);\n				int r=poz;\n				for(; r<signed(name_base[qy].size()); r++)\n					cout << name_base[qy][r];\n				r++;\n				cout << \" \";\n				if(r%width==0) cout << \"\\033[E\";\n				for(; r>poz; r--)\n				{\n					if(r%width==0)\n					{\n						cout << KEY_UP;\n						for(int i=0; i<width; i++)\n						{\n							cout << KEY_RIGHT;\n						}\n					}\n					else cout << KEY_LEFT;\n				}\n			}\n		}\n		else if(k==KEY_UP)\n		{\n			if(qy>0)\n			{\n				qy--;\n				while(poz>0)\n				{\n					cout << \" \";\n					if(poz+1%width==0)\n					{\n						cout << \" \\033[D\";\n						cout << KEY_UP;\n						for(int i=0; i<width; i++)\n						{\n							cout << KEY_RIGHT;\n						}\n					}\n					else cout << KEY_LEFT;\n					if(poz%width==0)\n					{\n						cout << KEY_UP;\n						for(int i=0; i<width; i++)\n						{\n							cout << KEY_RIGHT;\n						}\n					}\n					else cout << KEY_LEFT;\n					poz--;\n				}\n				poz=name_base[qy].size();\n				cout << name_base[qy];\n				if(poz%width==0) cout << \" \\033[D\";\n			}\n		}\n		else if(k==KEY_DOWN)\n		{\n			if(qy<signed(name_base.size())-1)\n			{\n				qy++;\n				while(poz>0)\n				{\n					cout << \" \";\n					if(poz+1%width==0)\n					{\n						cout << \" \\033[D\";\n						cout << KEY_UP;\n						for(int i=0; i<width; i++)\n						{\n							cout << KEY_RIGHT;\n						}\n					}\n					else cout << KEY_LEFT;\n					if(poz%width==0)\n					{\n						cout << KEY_UP;\n						for(int i=0; i<width; i++)\n						{\n							cout << KEY_RIGHT;\n						}\n					}\n					else cout << KEY_LEFT;\n					poz--;\n				}\n				poz=name_base[qy].size();\n				cout << name_base[qy];\n				if(poz%width==0) cout << \" \\033[D\";\n			}\n		}\n		else if(k==KEY_LEFT)\n		{\n			if(poz>0)\n			{\n				if(poz%width==0)\n				{\n					cout << KEY_UP;\n					for(int i=0; i<width; i++)\n					{\n						cout << KEY_RIGHT;\n					}\n				}\n				else cout << KEY_LEFT;\n				poz--;\n			}\n		}\n		else if(k==KEY_RIGHT)\n		{\n			if(poz<signed(name_base[qy].size()))\n			{\n				if(poz%width-width==-1) cout << \"\\033[E\";\n				else cout << KEY_RIGHT;\n				poz++;\n			}\n		}\n		else\n		{\n			if(k[k.size()-1]==10)\n			{\n				k.erase(k.size()-1, 1);\n				name_base[qy].insert(poz,k);\n				break;\n			}\n			int r=poz;\n			name_base[qy].insert(poz,k);\n			for(; r<signed(name_base[qy].size()); r++)\n				cout << name_base[qy][r];\n			if(r%width==0) cout << \" \\033[D\";\n			for(; r>signed(k.size())+poz; r--)\n			{\n				if(r%width==0)\n				{\n					cout << KEY_UP;\n					for(int i=0; i<width; i++)\n					{\n						cout << KEY_RIGHT;\n					}\n				}\n				else cout << KEY_LEFT;\n			}\n			poz+=k.size();\n			//cout << k;\n		}\n		z=getch();\n	}\n	while(poz<signed(name_base[qy].size()))\n	{\n		if(poz%width-width==-1) cout << \"\\033[E\";\n		else cout << KEY_RIGHT;\n		poz++;\n	}\n	cout << endl;\n	if(qy<signed(name_base.size())-1) name_base.pop_back();\n	w=name_base[qy];\n	v.push_back(w);\n	name_base.swap(v);\n}\n\n#endif\n//___________________________________________________\n\nconst bool zn[]={0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n				 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n				 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n				 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n				 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n				 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n				 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n				 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n				 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n		  var[]={0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n				 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n				 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n				 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n				 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n				 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n				 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n				 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n				 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\nvoid convert(string &w)\n{\n	string k=\"\";\n	k.swap(w);\n	if(k.size()>0)\n	{\n		unsigned int beg=1;\n		w+=k[0];\n		if(w[0]==',') w[0]='.';\n		else if(w[0]==' ')\n		{\n			while(k[beg]==' ' && beg<k.size())\n				beg++;\n			if(beg<k.size()) w[0]=k[beg];\n			else w=\"\";\n			beg++;\n		}\n		for(unsigned int i=beg; i<k.size(); i++)\n		{\n			if(k[i]==' ') continue;\n			if(k[i]==',') k[i]='.';\n			else if(w[w.size()-1]!='.' && k[i]!='.'\n					&& ((w[w.size()-1]=='!' && !zn[static_cast<int>(k[i])] && k[i]!=')')\n					|| (w[w.size()-1]==')' && !zn[static_cast<int>(k[i])] && k[i]!=')')\n					|| (k[i]=='(' && w[w.size()-1]!='(' && !zn[static_cast<int>(w[w.size()-1])])\n					|| (!var[static_cast<int>(w[w.size()-1])] && k[i]>47 && k[i]<58)\n					|| (w[w.size()-1]>47 && w[w.size()-1]<58 && !var[static_cast<int>(k[i])]))) w+='*';\n			w+=k[i];\n		}\n	}\n}\n\nbool identyfity(string &s)\n{\n	if(s.size()==0) return 0;\n	string k;\n	for(int i=0; i<static_cast<int>(s.size()); i++)\n	{\n		if(s[i]=='=') break;\n		else k+=s[i];\n	}\n	if(k.size()==s.size()) k=\"\";\n	else\n	{\n		for(int i=0; i<static_cast<int>(k.size()); i++)\n			if(var[static_cast<int>(s[i])] || s[i]=='.' || s[i]==',')\n			{\n				cout << \"Wrong variable name!\\n\";\n				return 0;\n			}\n	}\n	if(!don(s,(k.size()==0 ? 0:k.size()+1),s.size())) return 0;\n	if(!oper(s,(k.size()==0 ? 0:k.size()+1),s.size())) return 0;\n	bool erro=isnERR();\n	if(k.size()>0 && erro)\n	{\n		dn var;\n		var_base::read_var(\"A\", var);\n		var_base::add_var(k, var);\n		mcol(_blue);\n		cout << k;\n		mcol(_yellow);\n		cout << \" = \";\n		return 1;\n	}\nreturn erro;\n}\n\nint main(int avg, char **arg)\n{\n	//ios::sync_with_stdio(0);\n	bool arg1[]={1,1};\n	for(int i=1; i<avg; i++)\n	{\n		if(arg[i][0]=='-' && arg[i][1]=='-' && arg[i][2]=='h' && arg[i][3]=='e' && arg[i][4]=='l' && arg[i][5]=='p'){cout << \"Usage: Calc [options]\\nOptions:\\n  --help     Display this information\\n  --version  Dispaly Calc version\\n  -c         Run without synax highlighting\\n  -w         Run in mode: using `-c' and don't display start information, it's make to read from file\\n\";return 0;}\n		else if(arg[i][0]=='-' && arg[i][1]=='-' && arg[i][2]=='v' && arg[i][3]=='e' && arg[i][4]=='r' && arg[i][5]=='s' && arg[i][6]=='i' && arg[i][7]=='o' && arg[i][8]=='n'){cout << \"Calc version 2.4\\n\";return 0;}\n		else if(arg1[0] && arg[i][0]=='-' && arg[i][1]=='c' && arg[i][2]=='\\0'){_color=0;arg1[0]=0;}\n		else if(arg1[1] && arg[i][0]=='-' && arg[i][1]=='w' && arg[i][2]=='\\0')\n		{\n			arg[0]=0;\n			_color=0;\n			output[3]=1;\n			char znak=cin.get();\n			while(znak!=EOF)\n			{\n				string s;\n				while(znak!=10)\n				{\n					if(znak!=32)\n					{\n						s+=znak;\n					}\n					znak=cin.get();\n				}\n				if(s==\"exit\"){mcol(_default);return 0;}\n				else if(s==\"col-on\"){_color=1;scol();}\n				else if(s==\"col-off\"){_color=0;scol();color_default;}\n				else if(s==\"help\") help();\n				else if(s==\"settings\") settings();\n				else\n				{\n					convert(s);\n					if(identyfity(s))\n					{\n						dn a;\n						var_base::read_var(\"A\", a);\n						wypisz(a, output);\n						cout << \"\\n\";\n					}\n				}\n				znak=cin.get();\n			}\n			return 0;\n		}\n		else{cout << \"Calc: unrecognized option `\" << arg[i] << \"\\n\";return 0;}\n	}\n	fstream kalk_conf_file;\n	kalk_conf_file.open(\".kalk_config.cfg\", ios::in);\n	char buff[]={'0','0','1','1','1','\\0'};\n	bool ey=0;\n	if(kalk_conf_file.good())\n	{\n		kalk_conf_file.read(buff, 5);\n		kalk_conf_file.close();\n	}\n	else ey=1;\n	if(ey || kalk_conf_file.gcount()<5)\n	{\n		if(!ey) nhide_file();\n		kalk_conf_file.open(\".kalk_config.cfg\", ios::out);\n		if(kalk_conf_file.good()) kalk_conf_file << \"00111\";\n		kalk_conf_file.close();\n		hide_file();\n	}\n	output[0]=buff[0]-48;\n	output[1]=buff[1]-48;\n	output[2]=buff[2]-48;\n	output[3]=buff[3]-48;\n	_color=buff[4]-48;\n	mcol(_blue);\n	cout << \"To quit write: exit\\n\";\n	mcol(_green);\n	/******* ADD 'A' TO VARIaBLES *******/\n	var_base::_v.resize(2);\n	var_base::_v[0].t['A']=1;\n	var_base::_v[1].is=1;\n	var_base::_v[1].w.l.push_back(0);\n	var_base::_v[1].w.m.push_back(1);\n	var_base::_v[1].w.z=1;\n	/******* END *******/\n	while(1)\n	{\n		string s;\n		buffer(s);\n		if(s==\"exit\"){mcol(_default);return 0;}\n		else if(s==\"col-on\"){_color=1;scol();}\n		else if(s==\"col-off\"){_color=0;scol();color_default;}\n		else if(s==\"help\") help();\n		else if(s==\"settings\") settings();\n		else\n		{\n			convert(s);\n			mcol(_red);\n			if(identyfity(s))\n			{\n				dn a;\n				var_base::read_var(\"A\", a);\n				mcol(_blue);\n				wypisz(a, output);\n				cout << \"\\n\";\n			}\n		}\n		mcol(_green);\n	}\nreturn 0;\n}\n\n#include <complex>\n\n/*void czytaj(vector<int> &a)\n{\n	string s;\n	char k=cin.get();\n	while(k!=10 && k!=32)\n	{\n		s+=k;\n		k=cin.get();\n	}\n	int j=s.size()-1, i=0;\n	while(j>=0)\n	{\n		a.push_back(0);\n		for(int k=max(0,j-L+1); k<=j; k++)\n		{\n			a[i]=10*a[i]+(s[k]-'0');\n		}\n		j-=L;\n		i++;\n	 }\n}*/\n\nvoid wypisz(vector<int> a)\n{\n	int k=a.size()-1;\n	cout << a[k];\n	for(int i=k-1; i>=0; i--)\n	{\n		cout.width(L);\n		cout.fill('0');\n		cout << a[i];\n	}\n}\n\nvoid kas0(vector<int> &a)\n{\n	int o=0, i=a.size()-1;\n	while(i>0 && a[i]==0)\n	{\n		o++;\n		i--;\n	}\n	a.erase(a.end()-o, a.end());\n}\n\nvector<int> operator+(vector<int> a, vector<int> b)\n{\n	int al=a.size(), bl=b.size(), p=0;\n	vector<int> w(max(bl,al));\n	if(al<bl){a.swap(b);swap(al,bl);}\n	else\n	{\n		for(int i=0; i<bl; i++)\n		{\n			w[i]=a[i]+b[i]+p;\n			if(w[i]>=BASE){w[i]-=BASE;p=1;}\n			else{p=0;}\n		}\n		for(int i=bl; i<al; i++)\n		{\n			w[i]=a[i]+p;\n			if(w[i]>=BASE){w[i]-=BASE;p=1;}\n			else{p=0;}\n		}\n		if(p>0)\n		{\n			w.push_back(p);\n		}\n	}\nreturn w;\n}\n\nvoid operator+=(vector<int> &a, vector<int> b)\n{\n	int al=a.size(), bl=b.size(), p=0;\n	if(al<bl){a.insert(a.end(), bl-al, 0);al=a.size();}\n	for(int i=0; i<bl; i++)\n	{\n		a[i]+=b[i]+p;\n		if(a[i]>=BASE){a[i]-=BASE;p=1;}\n		else{p=0;}\n	}\n	for(int i=bl; i<al; i++)\n	{\n		a[i]+=p;\n		if(a[i]>=BASE){a[i]-=BASE;p=1;}\n		else{p=0;break;}\n	}\n	if(p>0)\n	{\n		a.push_back(p);\n	}\n}\n\nvector<int> operator-(vector<int> a, vector<int> b)\n{\n	int al=a.size(), bl=b.size(), p=0;\n	vector<int> w(al);\n	for(int i=0; i<bl; i++)\n	{\n		w[i]=a[i]-b[i]-p;\n		if(w[i]<0){w[i]+=BASE;p=1;}\n		else{p=0;}\n	}\n	for(int i=bl; i<al; i++)\n	{\n		w[i]=a[i]-p;\n		if(w[i]<0){w[i]+=BASE;p=1;}\n		else{p=0;}\n	}\n	kas0(w);\nreturn w;\n}\n\nvoid operator-=(vector<int> &a, vector<int> b)\n{\n	int al=a.size(), bl=b.size(), p=0;\n	for(int i=0; i<bl; i++)\n	{\n		a[i]-=b[i]+p;\n		if(a[i]<0){a[i]+=BASE;p=1;}\n		else{p=0;}\n	}\n	for(int i=bl; i<al; i++)\n	{\n		a[i]-=p;\n		if(a[i]<0){a[i]+=BASE;p=1;}\n		else{break;}\n	}\n	kas0(a);\n}\n\nvector<int> operator*(vector<int> a, int b)\n{\n	int al=a.size();\n	long long int g, p=0;\n	vector<int> w(al);\n	for(int i=0; i<al; i++)\n	{\n		g=(long long int)(a[i])*b+p;\n		p=g/BASE;\n		w[i]=g-p*BASE;\n	}\n	if(p>0){w.push_back(p);}\n	kas0(w);\nreturn w;\n}\n\nvoid operator*=(vector<int> &a, int b)\n{\n	int al=a.size();\n	long long int g, p=0;\n	for(int i=0; i<al; i++)\n	{\n		g=(long long int)(a[i])*b+p;\n		p=g/BASE;\n		a[i]=g-p*BASE;\n	}\n	if(p>0){a.push_back(p);}\n	kas0(a);\n}\n/*\nvector<int> operator*(vector<int> a, vector<int> b)\n{\n	int al=a.size(), bl=b.size(), od=0;\n	long long int g, p;\n	vector<int> w(1), k;\n	for(int i=0; i<bl; i++)\n	{\n		p=0;\n		k.resize(al);\n		for(int j=0; j<al; j++)\n		{\n			g=(long long int)(a[j])*b[i]+p;\n			p=g/BASE;\n			k[j]=g-p*BASE;\n		}\n		if(p>0){k.push_back(p);}\n		kas0(k);\n		int wl=w.size()-od, kl=k.size(), p=0;\n		if(wl<kl){w.insert(w.end(), kl-wl, 0);wl=w.size()-od;}\n		for(int j=0; j<kl; j++)\n		{\n			w[j+od]+=k[j]+p;\n			if(w[j+od]>=BASE){w[j+od]-=BASE;p=1;}\n			else{p=0;}\n		}\n		for(int j=kl; j<wl; j++)\n		{\n			w[j+od]+=p;\n			if(w[j+od]>=BASE){w[j+od]-=BASE;p=1;}\n			else{p=0;break;}\n		}\n		if(p>0)\n		{\n			w.push_back(p);\n		}\n		od++;\n	}\n	kas0(w);\nreturn w;\n}\n\nvoid operator*=(vector<int> &a, vector<int> b)\n{\n	int al=a.size(), bl=b.size(), od=0;\n	long long int g, p;\n	vector<int> w(1), k;\n	for(int i=0; i<bl; i++)\n	{\n		p=0;\n		k.resize(al);\n		for(int j=0; j<al; j++)\n		{\n			g=(long long int)(a[j])*b[i]+p;\n			p=g/BASE;\n			k[j]=g-p*BASE;\n		}\n		if(p>0){k.push_back(p);}\n		kas0(k);\n		int wl=w.size()-od, kl=k.size(), p=0;\n		if(wl<kl){w.insert(w.end(), kl-wl, 0);wl=w.size()-od;}\n		for(int j=0; j<kl; j++)\n		{\n			w[j+od]+=k[j]+p;\n			if(w[j+od]>=BASE){w[j+od]-=BASE;p=1;}\n			else{p=0;}\n		}\n		for(int j=kl; j<wl; j++)\n		{\n			w[j+od]+=p;\n			if(w[j+od]>=BASE){w[j+od]-=BASE;p=1;}\n			else{p=0;break;}\n		}\n		if(p>0)\n		{\n			w.push_back(p);\n		}\n		od++;\n	}\n	kas0(w);\n	a.swap(w);\n}\n*/\n#define cpx complex<double>\n\nvoid DFT(vector<cpx> &omega, int pw, vector<short int> &a, vector<cpx> &b)\n{\n	if(a.size()==1){b[0]=cpx(static_cast<long double>(a[0]),0.0);return;}\n	int n=a.size()>>1;\n	vector<short int> t0(n), t1(n);\n	for(unsigned int i=0; i<a.size(); i+=2)\n	{\n		t0[i>>1]=a[i];\n		t1[i>>1]=a[i+1];\n	}\n	vector<short int>().swap(a);\n	vector<cpx> y0(n), y1(n);\n	DFT(omega, pw<<1, t0, y0);\n	DFT(omega, pw<<1, t1, y1);\n	int nr=0;\n	for(int i=0; i<n; ++i)\n	{\n		cpx k=omega[nr]*y1[i];\n		b[i]=y0[i]+k;\n		b[i+n]=y0[i]-k;\n		nr+=pw;\n	}\n}\n\nvoid IDFT(vector<cpx> &omega, int pw, vector<cpx> &a)\n{\n	if(a.size()==1) return;\n	int n=a.size()>>1;\n	vector<cpx> t0(n), t1(n);\n	for(unsigned int i=0; i<a.size(); i+=2)\n	{\n		t0[i>>1]=a[i];\n		t1[i>>1]=a[i+1];\n	}\n	IDFT(omega, pw<<1, t0);\n	IDFT(omega, pw<<1, t1);\n	int nr=0;\n	for(int i=0; i<n; ++i)\n	{\n		cpx k=omega[nr]*t1[i];\n		a[i]=t0[i]+k;\n		a[i+n]=t0[i]-k;\n		nr+=pw;\n	}\n}\n\nvector<int> /*fft*/operator*(vector<int> a, vector<int> b)\n{\n	vector<short int> a1, b1;\n	stack<char> st;\n	int al=a.size(), bl=b.size();\n	for(int i=0; i<al; ++i)\n	{\n		int lol=a[i];\n		for(int j=0; j<9; ++j)\n		{\n			st.push(lol%10);\n			lol/=10;\n			if(st.size()==4)\n			{\n				short int u=0;\n				while(!st.empty())\n				{\n					u*=10;\n					u+=st.top();\n					st.pop();\n				}\n				a1.push_back(u);\n			}\n		}\n	}\n	if(!st.empty())\n	{\n		short int u=0;\n		while(!st.empty())\n		{\n			u*=10;\n			u+=st.top();\n			st.pop();\n		}\n		a1.push_back(u);\n	}\n	for(int i=0; i<bl; ++i)\n	{\n		int lol=b[i];\n		for(int j=0; j<9; ++j)\n		{\n			st.push(lol%10);\n			lol/=10;\n			if(st.size()==4)\n			{\n				short int u=0;\n				while(!st.empty())\n				{\n					u*=10;\n					u+=st.top();\n					st.pop();\n				}\n				b1.push_back(u);\n			}\n		}\n	}\n	if(!st.empty())\n	{\n		short int u=0;\n		while(!st.empty())\n		{\n			u*=10;\n			u+=st.top();\n			st.pop();\n		}\n		b1.push_back(u);\n	}\n	vector<int>().swap(a);\n	vector<int>().swap(b);\n	int o=0, qw=a1.size()-1;\n	while(qw>0 && a1[qw]==0)\n	{\n		++o;\n		--qw;\n	}\n	a1.erase(a1.end()-o, a1.end());\n	o=0;\n	qw=b1.size()-1;\n	while(qw>0 && b1[qw]==0)\n	{\n		++o;\n		--qw;\n	}\n	b1.erase(b1.end()-o, b1.end());\n	int p2=a1.size()+b1.size();\n	if(__builtin_popcount(p2)>1) // ilość zapalonych bitów\n	{\n		p2=1<<(32-__builtin_clz(p2)); // pozycja najstarszego zapalonego bitu\n	}\n	a1.resize(p2);\n	b1.resize(p2);\n	int p1=p2>>1;\n	vector<cpx> w(p2), w2(p2), omega(p1);\n	cpx trol0=cpx(cos(M_PI/p1),sin(M_PI/p1)), trol1=cpx(1.0,0.0);\n	for(int i=0; i<p1; ++i)\n	{\n		omega[i]=cpx(cos(M_PI*i/p1),sin(M_PI*i/p1));\n	}\n	DFT(omega, 1, a1, w);\n	DFT(omega, 1, b1, w2);\n	for(int i=0; i<p2; ++i)\n	{\n		w[i]*=w2[i];\n	}\n	vector<cpx>().swap(w2);\n	trol0=cpx(1.0,0.0)/cpx(cos(M_PI/p1),sin(M_PI/p1));\n	trol1=cpx(1.0,0.0);\n	for(int i=0; i<p1; ++i)\n	{\n		omega[i]=cpx(1.0,0.0)/cpx(cos(M_PI*i/p1),sin(M_PI*i/p1));\n	}\n	IDFT(omega, 1, w);\n	vector<short int> res(p2);\n	unsigned int q=0;\n	for(int i=0; i<p2; ++i)\n	{\n		q+=static_cast<unsigned int>(round(w[i].real()/p2));\n		res[i]=q%10000;\n		q/=10000;\n	}\n	o=0;\n	qw=p2-1;\n	while(qw>0 && res[qw]==0)\n	{\n		++o;\n		--qw;\n	}\n	res.erase(res.end()-o, res.end());\n	qw=res.size();\n	for(int i=0; i<qw; ++i)\n	{\n		int lol=res[i];\n		for(int j=0; j<4; ++j)\n		{\n			st.push(lol%10);\n			lol/=10;\n			if(st.size()==9)\n			{\n				int u=0;\n				while(!st.empty())\n				{\n					u*=10;\n					u+=st.top();\n					st.pop();\n				}\n				a.push_back(u);\n			}\n		}\n	}\n	if(!st.empty())\n	{\n		int u=0;\n		while(!st.empty())\n		{\n			u*=10;\n			u+=st.top();\n			st.pop();\n		}\n		a.push_back(u);\n	}\n	o=0;\n	qw=a.size()-1;\n	while(qw>0 && a[qw]==0)\n	{\n		++o;\n		--qw;\n	}\n	a.erase(a.end()-o, a.end());\nreturn a;\n}\n\nvoid /*fft*/operator*=(vector<int> &a, vector<int> b)\n{\n	vector<short int> a1, b1;\n	stack<char> st;\n	int al=a.size(), bl=b.size();\n	for(int i=0; i<al; ++i)\n	{\n		int lol=a[i];\n		for(int j=0; j<9; ++j)\n		{\n			st.push(lol%10);\n			lol/=10;\n			if(st.size()==4)\n			{\n				short int u=0;\n				while(!st.empty())\n				{\n					u*=10;\n					u+=st.top();\n					st.pop();\n				}\n				a1.push_back(u);\n			}\n		}\n	}\n	if(!st.empty())\n	{\n		short int u=0;\n		while(!st.empty())\n		{\n			u*=10;\n			u+=st.top();\n			st.pop();\n		}\n		a1.push_back(u);\n	}\n	for(int i=0; i<bl; ++i)\n	{\n		int lol=b[i];\n		for(int j=0; j<9; ++j)\n		{\n			st.push(lol%10);\n			lol/=10;\n			if(st.size()==4)\n			{\n				short int u=0;\n				while(!st.empty())\n				{\n					u*=10;\n					u+=st.top();\n					st.pop();\n				}\n				b1.push_back(u);\n			}\n		}\n	}\n	if(!st.empty())\n	{\n		short int u=0;\n		while(!st.empty())\n		{\n			u*=10;\n			u+=st.top();\n			st.pop();\n		}\n		b1.push_back(u);\n	}\n	vector<int>().swap(a);\n	vector<int>().swap(b);\n	int o=0, qw=a1.size()-1;\n	while(qw>0 && a1[qw]==0)\n	{\n		++o;\n		--qw;\n	}\n	a1.erase(a1.end()-o, a1.end());\n	o=0;\n	qw=b1.size()-1;\n	while(qw>0 && b1[qw]==0)\n	{\n		++o;\n		--qw;\n	}\n	b1.erase(b1.end()-o, b1.end());\n	int p2=a1.size()+b1.size();\n	if(__builtin_popcount(p2)>1) // ilość zapalonych bitów\n	{\n		p2=1<<(32-__builtin_clz(p2)); // pozycja najstarszego zapalonego bitu\n	}\n	a1.resize(p2);\n	b1.resize(p2);\n	int p1=p2>>1;\n	vector<cpx> w(p2), w2(p2), omega(p1);\n	cpx trol0=cpx(cos(M_PI/p1),sin(M_PI/p1)), trol1=cpx(1.0,0.0);\n	for(int i=0; i<p1; ++i)\n	{\n		omega[i]=cpx(cos(M_PI*i/p1),sin(M_PI*i/p1));\n	}\n	DFT(omega, 1, a1, w);\n	DFT(omega, 1, b1, w2);\n	for(int i=0; i<p2; ++i)\n	{\n		w[i]*=w2[i];\n	}\n	vector<cpx>().swap(w2);\n	trol0=cpx(1.0,0.0)/cpx(cos(M_PI/p1),sin(M_PI/p1));\n	trol1=cpx(1.0,0.0);\n	for(int i=0; i<p1; ++i)\n	{\n		omega[i]=cpx(1.0,0.0)/cpx(cos(M_PI*i/p1),sin(M_PI*i/p1));\n	}\n	IDFT(omega, 1, w);\n	vector<short int> res(p2);\n	unsigned int q=0;\n	for(int i=0; i<p2; ++i)\n	{\n		q+=static_cast<unsigned int>(round(w[i].real()/p2));\n		res[i]=q%10000;\n		q/=10000;\n	}\n	o=0;\n	qw=p2-1;\n	while(qw>0 && res[qw]==0)\n	{\n		++o;\n		--qw;\n	}\n	res.erase(res.end()-o, res.end());\n	qw=res.size();\n	for(int i=0; i<qw; ++i)\n	{\n		int lol=res[i];\n		for(int j=0; j<4; ++j)\n		{\n			st.push(lol%10);\n			lol/=10;\n			if(st.size()==9)\n			{\n				int u=0;\n				while(!st.empty())\n				{\n					u*=10;\n					u+=st.top();\n					st.pop();\n				}\n				a.push_back(u);\n			}\n		}\n	}\n	if(!st.empty())\n	{\n		int u=0;\n		while(!st.empty())\n		{\n			u*=10;\n			u+=st.top();\n			st.pop();\n		}\n		a.push_back(u);\n	}\n	o=0;\n	qw=a.size()-1;\n	while(qw>0 && a[qw]==0)\n	{\n		++o;\n		--qw;\n	}\n	a.erase(a.end()-o, a.end());\n}\n\nvoid fft_fast(vector<int> &a, vector<int> &b)\n{\n	vector<short int> a1, b1;\n	stack<char> st;\n	int al=a.size(), bl=b.size();\n	for(int i=0; i<al; ++i)\n	{\n		int lol=a[i];\n		for(int j=0; j<9; ++j)\n		{\n			st.push(lol%10);\n			lol/=10;\n			if(st.size()==4)\n			{\n				short int u=0;\n				while(!st.empty())\n				{\n					u*=10;\n					u+=st.top();\n					st.pop();\n				}\n				a1.push_back(u);\n			}\n		}\n	}\n	if(!st.empty())\n	{\n		short int u=0;\n		while(!st.empty())\n		{\n			u*=10;\n			u+=st.top();\n			st.pop();\n		}\n		a1.push_back(u);\n	}\n	for(int i=0; i<bl; ++i)\n	{\n		int lol=b[i];\n		for(int j=0; j<9; ++j)\n		{\n			st.push(lol%10);\n			lol/=10;\n			if(st.size()==4)\n			{\n				short int u=0;\n				while(!st.empty())\n				{\n					u*=10;\n					u+=st.top();\n					st.pop();\n				}\n				b1.push_back(u);\n			}\n		}\n	}\n	if(!st.empty())\n	{\n		short int u=0;\n		while(!st.empty())\n		{\n			u*=10;\n			u+=st.top();\n			st.pop();\n		}\n		b1.push_back(u);\n	}\n	vector<int>().swap(a);\n	int o=0, qw=a1.size()-1;\n	while(qw>0 && a1[qw]==0)\n	{\n		++o;\n		--qw;\n	}\n	a1.erase(a1.end()-o, a1.end());\n	o=0;\n	qw=b1.size()-1;\n	while(qw>0 && b1[qw]==0)\n	{\n		++o;\n		--qw;\n	}\n	b1.erase(b1.end()-o, b1.end());\n	int p2=a1.size()+b1.size();\n	if(__builtin_popcount(p2)>1) // ilość zapalonych bitów\n	{\n		p2=1<<(32-__builtin_clz(p2)); // pozycja najstarszego zapalonego bitu\n	}\n	a1.resize(p2);\n	b1.resize(p2);\n	int p1=p2>>1;\n	vector<cpx> w(p2), w2(p2), omega(p1);\n	cpx trol0=cpx(cos(M_PI/p1),sin(M_PI/p1)), trol1=cpx(1.0,0.0);\n	for(int i=0; i<p1; ++i)\n	{\n		omega[i]=cpx(cos(M_PI*i/p1),sin(M_PI*i/p1));\n	}\n	DFT(omega, 1, a1, w);\n	DFT(omega, 1, b1, w2);\n	for(int i=0; i<p2; ++i)\n	{\n		w[i]*=w2[i];\n	}\n	vector<cpx>().swap(w2);\n	trol0=cpx(1.0,0.0)/cpx(cos(M_PI/p1),sin(M_PI/p1));\n	trol1=cpx(1.0,0.0);\n	for(int i=0; i<p1; ++i)\n	{\n		omega[i]=cpx(1.0,0.0)/cpx(cos(M_PI*i/p1),sin(M_PI*i/p1));\n	}\n	IDFT(omega, 1, w);\n	vector<short int> res(p2);\n	unsigned int q=0;\n	for(int i=0; i<p2; ++i)\n	{\n		q+=static_cast<unsigned int>(round(w[i].real()/p2));\n		res[i]=q%10000;\n		q/=10000;\n	}\n	o=0;\n	qw=p2-1;\n	while(qw>0 && res[qw]==0)\n	{\n		++o;\n		--qw;\n	}\n	res.erase(res.end()-o, res.end());\n	qw=res.size();\n	for(int i=0; i<qw; ++i)\n	{\n		int lol=res[i];\n		for(int j=0; j<4; ++j)\n		{\n			st.push(lol%10);\n			lol/=10;\n			if(st.size()==9)\n			{\n				int u=0;\n				while(!st.empty())\n				{\n					u*=10;\n					u+=st.top();\n					st.pop();\n				}\n				a.push_back(u);\n			}\n		}\n	}\n	if(!st.empty())\n	{\n		int u=0;\n		while(!st.empty())\n		{\n			u*=10;\n			u+=st.top();\n			st.pop();\n		}\n		a.push_back(u);\n	}\n	o=0;\n	qw=a.size()-1;\n	while(qw>0 && a[qw]==0)\n	{\n		++o;\n		--qw;\n	}\n	a.erase(a.end()-o, a.end());\n}\n\n#undef cpx\n\nvector<int> operator/(vector<int> a, vector<int> b)\n{\n	if(a<b){vector<int> w(1);return w;}\n	else if(b.size()==1 && b[0]==1) return a;\n	int al=a.size(), bl=b.size(), iws=al-bl;\n	vector<int> w(iws+1), g;\n	while(iws>=0)\n	{\n		bool wr;\n		if(al-iws<bl) wr=0;\n		else if(al-iws>bl) wr=1;\n		else\n		{\n			int i=bl-1;\n			while(i>=0 && a[i+iws]==b[i])\n			{\n				i--;\n			}\n			if(i<0) wr=1;\n			else if(a[i+iws]>b[i]) wr=1;\n			else wr=0;\n		}\n		if(wr)\n		{\n			int p=0, k=999999999, c;\n			while(p<k)\n			{\n				c=(p+k)/2+1;\n				g=b;\n				g*=c;\n				int gl=g.size();\n				if(al-iws<gl) wr=1;\n				else if(al-iws>gl) wr=0;\n				else\n				{\n					int i=gl-1;\n					while(i>=0 && a[i+iws]==g[i])\n					{\n						i--;\n					}\n					if(i<0) wr=0;\n					else if(g[i]>a[i+iws]) wr=1;\n					else wr=0;\n				}\n				if(wr) k=c-1;\n				else p=c;\n			}\n			g=b;\n			g*=p;\n			int gl=g.size(), prz=0;\n			for(int i=0; i<gl; i++)\n			{\n				a[i+iws]-=g[i]+prz;\n				if(a[i+iws]<0){a[i+iws]+=BASE;prz=1;}\n				else{prz=0;}\n			}\n			for(int i=gl+iws; i<al; i++)\n			{\n				a[i]-=prz;\n				if(a[i]<0){a[i]+=BASE;prz=1;}\n				else{break;}\n			}\n			kas0(a);\n			al=a.size();\n			w[iws]=p;\n		}\n		iws--;\n	}\n	kas0(w);\nreturn w;\n}\n\nvoid operator/=(vector<int> &a, vector<int> b)\n{\n	if(a<b){a.resize(1);a[0]=0;return;}\n	else if(b.size()==1 && b[0]==1) return;\n	int al=a.size(), bl=b.size(), iws=al-bl;\n	vector<int> w(iws+1), g;\n	while(iws>=0)\n	{\n		bool wr;\n		if(al-iws<bl) wr=0;\n		else if(al-iws>bl) wr=1;\n		else\n		{\n			int i=bl-1;\n			while(i>=0 && a[i+iws]==b[i])\n			{\n				i--;\n			}\n			if(i<0) wr=1;\n			else if(a[i+iws]>b[i]) wr=1;\n			else wr=0;\n		}\n		if(wr)\n		{\n			int p=0, k=999999999, c;\n			while(p<k)\n			{\n				c=(p+k)/2+1;\n				g=b;\n				g*=c;\n				int gl=g.size();\n				if(al-iws<gl) wr=1;\n				else if(al-iws>gl) wr=0;\n				else\n				{\n					int i=gl-1;\n					while(i>=0 && a[i+iws]==g[i])\n					{\n						i--;\n					}\n					if(i<0) wr=0;\n					else if(g[i]>a[i+iws]) wr=1;\n					else wr=0;\n				}\n				if(wr) k=c-1;\n				else p=c;\n			}\n			g=b;\n			g*=p;\n			int gl=g.size(), prz=0;\n			for(int i=0; i<gl; i++)\n			{\n				a[i+iws]-=g[i]+prz;\n				if(a[i+iws]<0){a[i+iws]+=BASE;prz=1;}\n				else{prz=0;}\n			}\n			for(int i=gl+iws; i<al; i++)\n			{\n				a[i]-=prz;\n				if(a[i]<0){a[i]+=BASE;prz=1;}\n				else{break;}\n			}\n			kas0(a);\n			al=a.size();\n			w[iws]=p;\n		}\n		iws--;\n	}\n	a.swap(w);\n	kas0(a);\n}\n\nvector<int> operator%(vector<int> a, vector<int> b)\n{\n	int al=a.size(), bl=b.size(), iws=al-bl;\n	vector<int> g;\n	while(iws>=0)\n	{\n		bool wr;\n		if(al-iws<bl) wr=0;\n		else if(al-iws>bl) wr=1;\n		else\n		{\n			int i=bl-1;\n			while(i>=0 && a[i+iws]==b[i])\n			{\n				i--;\n			}\n			if(i<0) wr=1;\n			else if(a[i+iws]>b[i]) wr=1;\n			else wr=0;\n		}\n		if(wr)\n		{\n			int p=0, k=999999999, c;\n			while(p<k)\n			{\n				c=(p+k)/2+1;\n				g=b;\n				g*=c;\n				int gl=g.size();\n				if(al-iws<gl) wr=1;\n				else if(al-iws>gl) wr=0;\n				else\n				{\n					int i=gl-1;\n					while(i>=0 && a[i+iws]==g[i])\n					{\n						i--;\n					}\n					if(i<0) wr=0;\n					else if(g[i]>a[i+iws]) wr=1;\n					else wr=0;\n				}\n				if(wr) k=c-1;\n				else p=c;\n			}\n			g=b;\n			g*=p;\n			int gl=g.size(), prz=0;\n			for(int i=0; i<gl; i++)\n			{\n				a[i+iws]-=g[i]+prz;\n				if(a[i+iws]<0){a[i+iws]+=BASE;prz=1;}\n				else{prz=0;}\n			}\n			for(int i=gl+iws; i<al; i++)\n			{\n				a[i]-=prz;\n				if(a[i]<0){a[i]+=BASE;prz=1;}\n				else{break;}\n			}\n			kas0(a);\n			al=a.size();\n		}\n		iws--;\n	}\nreturn a;\n}\n\nvoid operator%=(vector<int> &a, vector<int> b)\n{\n	int al=a.size(), bl=b.size(), iws=al-bl;\n	vector<int> g;\n	while(iws>=0)\n	{\n		bool wr;\n		if(al-iws<bl) wr=0;\n		else if(al-iws>bl) wr=1;\n		else\n		{\n			int i=bl-1;\n			while(i>=0 && a[i+iws]==b[i])\n			{\n				i--;\n			}\n			if(i<0) wr=1;\n			else if(a[i+iws]>b[i]) wr=1;\n			else wr=0;\n		}\n		if(wr)\n		{\n			int p=0, k=999999999, c;\n			while(p<k)\n			{\n				c=(p+k)/2+1;\n				g=b;\n				g*=c;\n				int gl=g.size();\n				if(al-iws<gl) wr=1;\n				else if(al-iws>gl) wr=0;\n				else\n				{\n					int i=gl-1;\n					while(i>=0 && a[i+iws]==g[i])\n					{\n						i--;\n					}\n					if(i<0) wr=0;\n					else if(g[i]>a[i+iws]) wr=1;\n					else wr=0;\n				}\n				if(wr) k=c-1;\n				else p=c;\n			}\n			g=b;\n			g*=p;\n			int gl=g.size(), prz=0;\n			for(int i=0; i<gl; i++)\n			{\n				a[i+iws]-=g[i]+prz;\n				if(a[i+iws]<0){a[i+iws]+=BASE;prz=1;}\n				else{prz=0;}\n			}\n			for(int i=gl+iws; i<al; i++)\n			{\n				a[i]-=prz;\n				if(a[i]<0){a[i]+=BASE;prz=1;}\n				else{break;}\n			}\n			kas0(a);\n			al=a.size();\n		}\n		iws--;\n	}\n}\n\nvector<int> operator^(vector<int> a, vector<int> b)\n{\n	vector<int> d(1), w;\n	d[0]=1;\n	if(b.size()==1 && b[0]==0){return d;}\n	w=a;\n	string bin;\n	while(b>d)\n	{\n		if(__builtin_ctz(b[0])==0/*b[0]%2==1*/){bin='1'+bin;b[0]-=1;}\n		else{bin='0'+bin;}\n		int r=0, pom=0;\n		for(int i=b.size()-1; i>=0; i--)\n		{\n			pom=b[i];\n			{\n				b[i]+=BASE*r;\n				b[i]>>=1;\n			}\n			r=pom-(b[i]<<1);\n		}\n		if(b[b.size()-1]==0){b.pop_back();}\n	}\n	int bins=bin.size();\n	for(int i=bins-1; i>=0; i++)\n	{\n		fft_fast(a,a);\n		if(bin[i]) fft_fast(a,w);\n	}\nreturn w;\n}\n\nvoid operator^=(vector<int> &a, vector<int> b)\n{\n	if(b.size()==1 && b[0]==0){a.resize(1);a[0]=1;return;}\n	vector<int> d(1), w=a;\n	d[0]=1;\n	vector<bool> bin;\n	while(b>d)\n	{\n		if(__builtin_ctz(b[0])==0/*b[0]%2==1*/){bin.push_back(1);b[0]-=1;}\n		else{bin.push_back(0);}\n		int r=0, pom=0;\n		for(int i=b.size()-1; i>=0; i--)\n		{\n			pom=b[i];\n			{\n				b[i]+=BASE*r;\n				b[i]>>=1;\n			}\n			r=pom-(b[i]<<1);\n		}\n		if(b[b.size()-1]==0){b.pop_back();}\n	}\n	int bins=bin.size();\n	for(int i=bins-1; i>=0; i--)\n	{\n		fft_fast(a,a);\n		if(bin[i]) fft_fast(a,w);\n	}\n}\n\nbool operator<(vector<int> a, vector<int> b)\n{\n	int al=a.size(), bl=b.size();\n	if(bl<al) return 0;\n	if(bl>al) return 1;\n	int i=al-1;\n	while(i>=0 && a[i]==b[i])\n	{\n		i--;\n	}\n	if(i<0 || a[i]>b[i]) return 0;\nreturn 1;\n}\n\nbool operator>(vector<int> a, vector<int> b)\n{\n	int al=a.size(), bl=b.size();\n	if(al<bl) return 0;\n	if(al>bl) return 1;\n	int i=al-1;\n	while(i>=0 && a[i]==b[i])\n	{\n		i--;\n	}\n	if(i<0 || a[i]<b[i]) return 0;\nreturn 1;\n}\n\nbool operator==(vector<int> a, vector<int> b)\n{\n	int al=a.size(), bl=b.size();\n	if(al!=bl) return 0;\n	int i=al-1;\n	while(i>=0 && a[i]==b[i])\n	{\n		i--;\n	}\n	if(i<0) return 1;\nreturn 0;\n}\n\nbool operator>=(vector<int> a, vector<int> b)\n{\n	int al=a.size(), bl=b.size();\n	if(bl<al) return 1;\n	if(bl>al) return 0;\n	int i=al-1;\n	while(i>=0 && a[i]==b[i])\n	{\n		i--;\n	}\n	if(i<0 || a[i]>b[i]) return 1;\nreturn 0;\n}\n\nbool operator<=(vector<int> a, vector<int> b)\n{\n	int al=a.size(), bl=b.size();\n	if(al<bl) return 1;\n	if(al>bl) return 0;\n	int i=al-1;\n	while(i>=0 && a[i]==b[i])\n	{\n		i--;\n	}\n	if(i<0 || a[i]<b[i]) return 1;\nreturn 0;\n}\n\nbool operator!=(vector<int> a, vector<int> b)\n{\n	int al=a.size(), bl=b.size();\n	if(al!=bl) return 1;\n	int i=al-1;\n	while(i>=0 && a[i]==b[i])\n	{\n		i--;\n	}\n	if(i<0) return 0;\nreturn 1;\n}\n\nvector<int> nwd(vector<int> a, vector<int> b)\n{\n	vector<int> d(1), c;\n	while(b!=d)\n	{\n		c.swap(a);\n		c%=b;\n		a.swap(b);\n		b.swap(c);\n	}\nreturn a;\n}\n\nvoid nwdp(vector<int> a, vector<int> b, vector<int> &k)\n{\n	vector<int> d(1), c;\n	while(b!=d)\n	{\n		c.swap(a);\n		c%=b;\n		a.swap(b);\n		b.swap(c);\n	}\n	k.swap(a);\n}\n\nint logcal(vector<int> a)\n{\n	int s=a.size(), w=L*(s-1), d;\n	d=a[s-1];\n	if(d<100000)\n	{\n		if(d<1000)\n		{\n			if(d<10){w+=1;}\n			else if(d<100){w+=2;}\n			else{w+=3;}\n		}\n		else\n		{\n			if(d<10000){w+=4;}\n			else{w+=5;}\n		}\n	}\n	else\n	{\n		if(d<10000000)\n		{\n			if(d<1000000){w+=6;}\n			else{w+=7;}\n		}\n		else\n		{\n			if(d<100000000){w+=8;}\n			else{w+=9;}\n		}\n	}\nreturn w;\n}\n\n\nbool przek=false;\n\nvoid opp(dn &a)\n{\n	if(a.l.size()==1 && a.l[0]==0){a.z=1;return;}\n	if(a.z==1) a.z=0;\n	else a.z=1;\n}\n\nbool don(string &s, int begin, int end)\n{\n	end--;\n	int br=0, z=0, num=0, krp=0, m=0;\n	bool var=0;\n	if(s[begin]=='!')\n	{\n		cout << \"Wrong argument: '!'!\\n\";\n		return false;\n	}\n	if(begin+1<end && (s[begin]=='-' || s[begin]=='+') && (s[begin+1]=='-' || s[begin+1]=='+'))\n	{\n		cout << \"Wrong argument: '\" << s[begin+1] << \"'!\\n\";\n		return false;\n	}\n	for(int i=begin; i<=end; i++)\n	{\n		if(s[i]=='(')\n		{\n			br++;\n			num=0;\n			var=false;\n			m=0;\n			krp=0;\n			z=0;\n		}\n		else if(s[i]==')')\n		{\n			br--;\n			if(br<0 || num==0)\n			{\n				cout << \"Wrong parentheses layout!\\n\";\n				return false;\n			}\n			z=0;\n		}\n		else if(s[i]=='.')\n		{\n			if(num==0 || krp>0 || i==end || s[i+1]<'0' || s[i+1]>'9' || var)\n			{\n				cout << \"Wrong number writing!\\n\";\n				return false;\n			}\n			krp++;\n		}\n		else if(s[i]=='+' || s[i]=='-')\n		{\n			if(m==0 && !(i==end || s[i+1]==')'))\n			{\n				if(z==0) z++;\n				else m++;\n			}\n			else\n			{\n				cout << \"Wrong argument: '\" << s[i] << \"'!\\n\";\n				return false;\n			}\n			num=0;\n			var=false;\n			krp=0;\n		}\n		else if(s[i]=='*' || s[i]=='/' || s[i]=='%' || s[i]=='^')\n		{\n			z++;\n			if(z>1 || num==0 || i==end || s[i+1]==')')\n			{\n				cout << \"Wrong argument: '\" << s[i] << \"'!\\n\";\n				return false;\n			}\n			num=0;\n			var=false;\n			krp=0;\n			m=0;\n		}\n		else if(s[i]=='!')\n		{\n			z=0;\n			m=0;\n			num=1;\n			krp=0;\n			if(s[i-1]=='+' || s[i-1]=='-' || s[i-1]=='*' || s[i-1]=='/' || s[i-1]=='%' || s[i-1]=='^' || s[i-1]=='(')\n			{\n				cout << \"Wrong argument: '!'!\\n\";\n				return false;\n			}\n		}\n		else if(s[i]>='0' && s[i]<='9')\n		{\n			num++;\n			z=0;\n			m=0;\n		}\n		else\n		{\n			num++;\n			z=0;\n			m=0;\n			var=true;\n		}\n	}\n	if(br!=0)\n	{\n		cout << \"Wrong parentheses layout!\\n\";\n		return false;\n	}\n	if(z>0)\n	{\n		char t;\n		if(m>0) t=s[end-1];\n		else t=s[end];\n		cout << z << \" \" << m << \"Wrong argument: '\" << t << \"'!\\n\";\n		return false;\n	}\nreturn true;\n}\n\ndn zmien(string &s, int lp, int lk)\n{\n	dn a;\n	a.m.push_back(10);\n	a.z=1;\n	int j=lk-1, i=0, m=lk;\n	for(int y=lp; y<lk; y++)\n	{\n		if(s[y]=='.'){s.erase(y, 1);m=y;lk--;j--;przek=1;break;}\n	}\n	while(lp<lk-1 && s[lp]=='0')\n		lp++;\n	while(j>=lp)\n	{\n		a.l.push_back(0);\n		for(int k=max(lp,j-L+1); k<=j; k++)\n		{\n			a.l[i]*=10;\n			a.l[i]+=s[k]-'0';\n		}\n		j-=L;\n		i++;\n	}\n	vector<int> ku(1);\n	ku[0]=lk-m;\n	a.m^=ku;\n	nwdp(a.l, a.m, ku);\n	a.l/=ku;\n	a.m/=ku;\n	return a;\n}\n\nint pri(char a)\n{\n	if(a=='^'){return 4;}\n	if(a=='*' || a=='/' || a=='%'){return 3;}\n	if(a=='+' || a=='-'){return 2;}\n	if(a=='(' || a==')'){return 1;}\nreturn 0;\n}\n\nvoid dzial(vector<dn> &a, vector<bool> &mi, vector<char> &z, int &in, char znak)\n{\n	int t=a.size()-1, f=pri(znak);\n	if(f==4 || t<1) return;\n	while(t>=1 && pri(z[t-1+in])>f)\n	{\n		if(mi[t+in]){opp(a[t]);mi[t+in]=0;}\n		if(z[t-1+in]=='^'){a[t-1]^=a[t];}\n		else\n		{\n			if(mi[t-1+in]){opp(a[t-1]);mi[t-1+in]=0;}\n			if(z[t-1+in]=='+'){a[t-1]+=a[t];}\n			else if(z[t-1+in]=='-'){a[t-1]-=a[t];}\n			else if(z[t-1+in]=='*'){a[t-1]*=a[t];}\n			else if(z[t-1+in]=='/'){a[t-1]/=a[t];}\n			else if(z[t-1+in]=='%'){a[t-1]%=a[t];}\n		}\n		a.pop_back();\n		z.pop_back();\n		mi.pop_back();\n		t--;\n	}\n	if(t>0 && f!=1 && f==pri(z[t-1+in]))\n	{\n		if(mi[t+in]){opp(a[t]);mi[t+in]=0;}\n		if(z[t-1+in]=='^'){a[t-1]^=a[t];}\n		else\n		{\n			if(mi[t-1+in]){opp(a[t-1]);mi[t-1+in]=0;}\n			if(z[t-1+in]=='+'){a[t-1]+=a[t];}\n			else if(z[t-1+in]=='-'){a[t-1]-=a[t];}\n			else if(z[t-1+in]=='*'){a[t-1]*=a[t];}\n			else if(z[t-1+in]=='/'){a[t-1]/=a[t];}\n			else if(z[t-1+in]=='%'){a[t-1]%=a[t];}\n		}\n		a.pop_back();\n		z.pop_back();\n		mi.pop_back();\n		t--;\n	}\n}\n\nstring f_pos_to_str(int p, int k, string &s)\n{\n	string w;\n	for(int i=p; i<k; i++)\n		w+=s[i];\nreturn w;\n}\n\nbool oper(string s, int start, int end)\n{\n	dn emp;\n	vector<dn> a;\n	vector<char> z;\n	vector<bool> mi;\n	bool m=0, var=0;\n	int t=start, in=0;\n	for(int i=start; i<end; i++)\n	{\n		if(s[i]=='!')\n		{\n			if(t<i)\n			{\n				if(var)\n				{\n					if(var_base::read_var(f_pos_to_str(t, i, s), emp)){a.push_back(emp);mi.push_back(m);}\n					else{cout << \"Unknown variable: \" << f_pos_to_str(t, i, s) << endl;return false;}\n				}\n				else\n				{\n					a.push_back(zmien(s, t, i));\n					mi.push_back(m);\n					if(przek){i--;end--;przek=false;}\n				}\n				m=0;\n			}\n			t=i+1;\n			factorial(a[a.size()-1]);\n		}\n		else if(s[i]=='-')\n		{\n			if(t>=i)\n			{\n				if(i>0 && s[i-1]=='!')\n				{\n					t=i+1;\n					z.push_back(s[i]);\n				}\n				else{m=1;t=i+1;}\n			}\n			else\n			{\n				if(var)\n				{\n					if(var_base::read_var(f_pos_to_str(t, i, s), emp)) a.push_back(emp);\n					else{cout << \"Unknown variable: \" << f_pos_to_str(t, i, s) << endl;return false;}\n				}\n				else{a.push_back(zmien(s, t, i));if(przek){i--;end--;przek=0;}}\n				mi.push_back(m);\n				m=0;\n				dzial(a, mi, z, in, s[i]);\n				t=i+1;\n				z.push_back(s[i]);\n			}\n		}\n		else if(s[i]=='+' || s[i]=='*' || s[i]=='/' || s[i]=='%' || s[i]=='^')\n		{\n			if(t<i)\n			{\n				if(var)\n				{\n					if(var_base::read_var(f_pos_to_str(t, i, s), emp)) a.push_back(emp);\n					else{cout << \"Unknown variable: \" << f_pos_to_str(t, i, s) << endl;return false;}\n				}\n				else\n				{\n					a.push_back(zmien(s, t, i));\n					if(przek){i--;end--;przek=0;}\n				}\n				mi.push_back(m);\n				m=0;\n				dzial(a, mi, z, in, s[i]);\n				t=i+1;\n				z.push_back(s[i]);\n			}\n			else if(i>0 && s[i-1]=='!')\n			{\n				t=i+1;\n				z.push_back(s[i]);\n			}\n			else t=i+1;\n		}\n		else if(s[i]=='(' || s[i]==')')\n		{\n			if(s[i]=='(')\n			{\n				z.push_back('(');\n				mi.push_back(m);\n				m=0;\n				in++;\n				t=i+1;\n			}\n			else\n			{\n				if(var)\n				{\n					if(var_base::read_var(f_pos_to_str(t, i, s), emp)){a.push_back(emp);mi.push_back(m);}\n					else{cout << \"Unknown variable: \" << f_pos_to_str(t, i, s) << endl;return false;}\n				}\n				else\n				{\n					a.push_back(zmien(s, t, i));\n					mi.push_back(m);\n					if(przek) przek=0;\n				}\n				m=0;\n				t=i+1;\n				dzial(a, mi, z, in, s[i]);\n				z.pop_back();\n				if(mi[mi.size()-1]) opp(a[a.size()-1]);\n				mi.pop_back();\n				in--;\n				if(i<end-1 && s[i+1]!=')' && s[i+1]!='!')\n				{\n					dzial(a, mi, z, in, s[i+1]);\n					z.push_back(s[i+1]);\n					i++;\n					t++;\n				}\n			}\n		}\n		else if(s[i]>47 && s[i]<58) var=0;\n		else var=1;\n	}\n	if(t<end)\n	{\n		if(var)\n		{\n			if(var_base::read_var(f_pos_to_str(t, end, s), emp)){a.push_back(emp);mi.push_back(m);}\n			else{cout << \"Unknown variable: \" << f_pos_to_str(t, end, s) << endl;return false;}\n		}\n		else\n		{\n			a.push_back(zmien(s, t, end));\n			mi.push_back(m);\n			if(przek) przek=0;\n		}\n	}\n	dzial(a, mi, z, in, '0');\n	if(mi[0]) opp(a[0]);\n	var_base::add_var(\"A\", a[0]);\nreturn true;\n}\n\n\nbool Error0=0, Error1=0, Error2=0, Error3=0;\n\n/*void czytaj(dn &a)\n{\n	a.l.resize(1,1);\n	string s;\n	char z=getchar();\n	if(z==10 || z==32){a.l.resize(1);a.l[0]=0;a.z=1;return;}\n	if(z=='-'){a.z=0;}\n	else{a.z=1;s+=z;}\n	z=getchar();\n	while(z!=10 && z!=32)\n	{\n		s+=z;\n		z=getchar();\n	}\n	if(s==\"0\"){a.l.resize(1);a.l[0]=0;a.z=1;return;}\n	int j=s.size()-1, i=0;\n	while(j>=0)\n	{\n		a.l.push_back(0);\n		for(int k=max(0,j-L+1); k<=j; k++)\n		{\n			a.l[i]=10*a.l[i]+(s[k]-'0');\n		}\n		j-=L;\n		i++;\n	 }\n}*/\n\nvoid wypisz(dn a, bool *output)\n{\n	vector<int> g(1), wyk=a.l;\n	if(output[0])\n	{\n		if(a.z==0){mcol(_yellow);cout << \"-\";mcol(_blue);}\n		wypisz(a.l);\n		if(!(a.m.size()==1 && a.m[0]==1))\n		{\n			mcol(_red);\n			cout << \"/\";\n			mcol(_blue);\n			wypisz(a.m);\n		}\n	}\n	if(output[1])\n	{\n		if(a.l>a.m)\n		{\n			g=a.l/a.m;\n			a.l-=g*a.m;\n			if(output[0] && !(a.l.size()==1 && a.l[0]==0))\n			{\n				mcol(_yellow);\n				cout << \" = \";\n				if(!a.z) cout << \"-(\";\n				mcol(_blue);\n				wypisz(g);\n				mcol(_yellow);\n				cout << \" + \";\n				mcol(_blue);\n				wypisz(a.l);\n				mcol(_red);\n				cout << \"/\";\n				mcol(_blue);\n				wypisz(a.m);\n				if(!a.z){mcol(_yellow);cout << \")\";mcol(_blue);}\n			}\n			else if(!output[0])\n			{\n				mcol(_yellow);\n				if(a.l.size()==1 && a.l[0]==0)\n				{\n					if(!a.z) cout << \"-\";\n					mcol(_blue);\n					wypisz(g);\n				}\n				else\n				{\n					if(!a.z) cout << \"-(\";\n					mcol(_blue);\n					wypisz(g);\n					mcol(_yellow);\n					cout << \" + \";\n					mcol(_blue);\n					wypisz(a.l);\n					mcol(_red);\n					cout << \"/\";\n					mcol(_blue);\n					wypisz(a.m);\n					if(!a.z){mcol(_yellow);cout << \")\";mcol(_blue);}\n				}\n			}\n\n		}\n		else if(!output[0])\n		{\n			if(a.z==0){mcol(_yellow);cout << \"-\";mcol(_blue);}\n			wypisz(a.l);\n			if(!(a.m.size()==1 && a.m[0]==1))\n			{\n				mcol(_red);\n				cout << \"/\";\n				mcol(_blue);\n				wypisz(a.m);\n			}\n			g=a.l;\n			g/=a.m;\n			a.l-=g*a.m;\n		}\n		else\n		{\n			g=a.l;\n			g/=a.m;\n			a.l-=g*a.m;\n		}\n	}\n	if(output[2])\n	{\n		if(!output[1])\n		{\n			if(a.m.size()==1 && a.m[0]==1)\n			{\n				g.swap(a.l);\n				vector<int>(1,0).swap(a.l);\n			}\n			else\n			{\n				g=a.l;\n				g/=a.m;\n				a.l-=a.m*g;\n			}\n		}\n		if((output[0] || output[1]) && !(a.l.size()==1 && a.l[0]==0))\n		{\n			mcol(_yellow);\n			cout << \" = \";\n			if(!a.z) cout << \"-\";\n			mcol(_blue);\n			wypisz(g);\n		}\n		else if(!output[0] && !output[1])\n		{\n			mcol(_yellow);\n			if(!a.z) cout << \"-\";\n			mcol(_blue);\n			wypisz(g);\n		}\n		if(!(a.l.size()==1 && a.l[0]==0))\n		{\n			a.l.insert(a.l.begin(), 5, 0);\n			a.l/=a.m;\n			string s, tos;\n			for(int i=45-logcal(a.l); i>0; i--)\n				s+=\"0\";\n			s+=to_string(a.l[a.l.size()-1]);\n			for(int i=a.l.size()-2; i>0; i--)\n			{\n				tos=to_string(a.l[i]);\n				for(int j=tos.size(); j<9; j++)\n					s+=\"0\";\n				s+=tos;\n			}\n			//zaokrąglanie\n			if(a.l[0]>499999999)\n			{\n				for(int i=s.size()-1; i>=0; i++)\n				{\n					s[i]++;\n					if(s[i]>58){s[i]-=10;}\n					else break;\n				}\n			}\n			//usuwanie końcowych zer\n			for(int i=s.size()-1; i>=0 && s[i]==48; i--)\n				s.erase(i, 1);\n			if(!s.empty())\n			{\n				mcol(_red);\n				cout << \".\";\n				mcol(_blue);\n				cout << s;\n			}\n		}\n	}\n	if(output[3])\n	{\n		if(output[0] || output[1] || output[2])\n		{\n			mcol(_yellow);\n			cout << \" = \";\n			mcol(_blue);\n		}\n		if(wyk.size()==0 || (wyk.size()==1 && wyk[0]==0))\n		{\n			cout << \"0\";\n		}\n		else\n		{\n			if(!a.z)\n			{\n				mcol(_yellow);\n				cout << \"-\";\n				mcol(_blue);\n			}\n			int lg=wyk.size()-a.m.size()-3;\n			string s, k;\n			if(lg>0) wyk.erase(wyk.begin(), wyk.begin()+lg);\n			else wyk.insert(wyk.begin(), -lg, 0);\n			lg*=9;\n			wyk/=a.m;\n			s+=to_string(wyk[wyk.size()-1]);\n			for(int i=wyk.size()-2; i>=0; i--)\n			{\n				k=to_string(wyk[i]);\n				for(int j=9-k.size(); j>0; j--)\n					s+='0';\n				s+=k;\n			}\n			lg+=s.size()-1;\n			s.erase(11,s.size()-11);\n			for(int i=s.size()-1; i>0 && s[i]==48; i--)\n				s.erase(i, 1);\n			cout << s[0];\n			if(s.size()>1)\n			{\n				mcol(_red);\n				cout << \".\";\n				mcol(_blue);\n			}\n			for(unsigned int i=1; i<s.size(); i++)\n				cout << s[i];\n			mcol(_yellow);\n			cout << \"*\";\n			mcol(_blue);\n			cout << \"10\";\n			mcol(_red);\n			cout << \"^\";\n			if(lg<0){cout << \"-\";lg=-lg;}\n			mcol(_blue);\n			cout << lg;\n		}\n	}\n}\n\ndn operator+(dn a, dn b)\n{\n	dn w;\n	vector<int> p, h=b.m;\n	nwdp(a.m, b.m, p);\n	h/=p;\n	fft_fast(a.l,h);\n	h=a.m;h/=p;\n	fft_fast(b.l,h);\n	w.m=h;\n	fft_fast(w.m,a.m);\n	if(a.z==b.z)\n	{\n		w.z=a.z;\n		w.l=a.l;w.l+=b.l;\n	}\n	else\n	{\n		if(a.l>b.l)\n		{\n			w.l=a.l;w.l-=b.l;\n			if(a.z){w.z=1;}\n			else{w.z=0;}\n		}\n		else\n		{\n			w.l=b.l;w.l-=a.l;\n			if(w.l.size()==1 && w.l[0]==0){w.z=1;}\n			else if(a.z){w.z=0;}\n			else{w.z=1;}\n		}\n	}\n	p=nwd(w.l, w.m);\n	w.l/=p;\n	w.m/=p;\nreturn w;\n}\n\nvoid operator+=(dn &a, dn b)\n{\n	vector<int> p, h=a.m;\n	nwdp(a.m, b.m, p);\n	h/=p;\n	fft_fast(b.l,h);\n	h=b.m;h/=p;\n	fft_fast(a.l,h);\n	fft_fast(a.m,h);\n	if(a.z==b.z){a.l+=b.l;}\n	else\n	{\n		if(a.l>b.l)\n		{\n			a.l-=b.l;\n			if(b.z){a.z=0;}\n			else{a.z=1;}\n		}\n		else\n		{\n			a.l=b.l-a.l;\n			if(a.l.size()==1 && a.l[0]==0){a.z=1;}\n			else if(a.z){a.z=0;}\n			else{a.z=1;}\n		}\n	}\n	p=nwd(a.l, a.m);\n	a.l/=p;\n	a.m/=p;\n}\n\ndn operator-(dn a, dn b)\n{\n	if(!b.z){b.z=1;return a+b;}\n	dn w;\n	vector<int> p, h=b.m;\n	nwdp(a.m, b.m, p);\n	h/=p;\n	fft_fast(a.l,h);\n	h=a.m;h/=p;\n	fft_fast(b.l,h);\n	w.m=h;\n	fft_fast(w.m,a.m);\n	if(a.l<b.l)\n	{\n		if(a.z){w.l=b.l-a.l;}\n		else{w.l=a.l+b.l;}\n		w.z=0;\n	}\n	else\n	{\n		if(a.z){w.z=1;w.l=a.l-b.l;}\n		else{w.z=0;w.l=a.l+b.l;}\n	}\n	nwdp(w.l, w.m, p);\n	w.l/=p;\n	w.m/=p;\nreturn w;\n}\n\nvoid operator-=(dn &a, dn b)\n{\n	if(!b.z){b.z=1;a+=b;return;}\n	vector<int> p, h=a.m;\n	nwdp(a.m, b.m, p);\n	h/=p;\n	fft_fast(b.l,h);\n	h=b.m;h/=p;\n	fft_fast(a.l,h);\n	fft_fast(a.m,h);\n	if(a.l<b.l)\n	{\n		if(a.z){a.l=b.l-a.l;}\n		else{a.l+=b.l;}\n		a.z=0;\n	}\n	else\n	{\n		if(a.z){a.z=1;a.l-=b.l;}\n		else{a.z=0;a.l+=b.l;}\n	}\n	nwdp(a.l, a.m, p);\n	a.l/=p;\n	a.m/=p;\n}\n\ndn operator*(dn a, dn b)\n{\n	dn w;\n	if(a.z==b.z){w.z=1;}\n	else{w.z=0;}\n	w.l=a.l;\n	fft_fast(w.l,b.l);\n	w.m=a.m;\n	fft_fast(w.m,b.m);\n	vector<int> p;\n	nwdp(w.l, w.m, p);\n	w.l/=p;\n	w.m/=p;\nreturn w;\n}\n\nvoid operator*=(dn &a, dn b)\n{\n	if(a.z==b.z){a.z=1;}\n	else{a.z=0;}\n	fft_fast(a.l,b.l);\n	fft_fast(a.m,b.m);\n	vector<int> p;\n	nwdp(a.l, a.m, p);\n	a.l/=p;\n	a.m/=p;\n	if(a.l.size()==1 && a.l[0]==0) a.z=1;\n}\n\ndn operator/(dn a, dn b)\n{\n	dn w;\n	if(b.l.size()==1 && b.l[0]==0){Error0=1;return a;}\n	if(a.z==b.z){w.z=1;}\n	else{w.z=0;}\n	w.l=a.m;\n	fft_fast(w.l,b.l);\n	w.m=a.l;\n	fft_fast(w.m,b.m);\n	vector<int> p;\n	nwdp(w.l, w.m, p);\n	w.l/=p;\n	w.m/=p;\nreturn w;\n}\n\nvoid operator/=(dn &a, dn b)\n{\n	if(b.l.size()==1 && b.l[0]==0){Error0=1;return;}\n	if(a.z==b.z){a.z=1;}\n	else{a.z=0;}\n	fft_fast(a.l,b.m);\n	fft_fast(a.m,b.l);\n	vector<int> p;\n	nwdp(a.l, a.m, p);\n	a.l/=p;\n	a.m/=p;\n}\n\ndn operator%(dn a, dn b)\n{\n	dn w;\n	if(!(a.m.size()==1 && a.m[0]==1) || !(b.m.size()==1 && b.m[0]==1))\n	{Error1=1;return w;}\n	w.z=1;\n	w.l=a.l%b.l;\n	if((a.z==0 && b.z==1) || (a.z==b.z && b.z==0)){if(!(w.l.size()==1 && w.l[0]==0)){w.l=b.l-w.l;}}\nreturn w;\n}\n\nvoid operator%=(dn &a, dn b)\n{\n	if(!(a.m.size()==1 && a.m[0]==1) || !(b.m.size()==1 && b.m[0]==1))\n	{Error1=1;return;}\n	a.l%=b.l;\n	if((a.z==0 && b.z==1) || (a.z==b.z && b.z==0)){if(!(a.l.size()==1 && a.l[0]==0)){a.l=b.l-a.l;}}\n	a.z=1;\n}\n\ndn operator^(dn a, dn b)\n{\n	dn w;\n	if(!(b.m.size()==1 && b.m[0]==1)){Error2=1;}\n	if(!a.z && b.l[0]%2==1){a.z=0;}\n	else{a.z=1;}\n	w.l=a.l^b.l;\n	w.l=a.m^b.l;\n	if(!b.z){w.l.swap(w.m);}\nreturn w;\n}\n\nvoid operator^=(dn &a, dn b)\n{\n	if(!b.z){a.l.swap(a.m);}\n	if(!(b.m.size()==1 && b.m[0]==1)){Error2=1;}\n	if(!a.z && b.l[0]%2==1){a.z=0;}\n	else{a.z=1;}\n	a.l^=b.l;\n	a.m^=b.l;\n}\n\nbool operator>(dn a, dn b)\n{\n	if(a.z==0 && b.z==1){return 0;}\n	if(a.z==1 && b.z==0){return 1;}\n	if(a.z==0 && b.z==0){return a.l<b.l;}\nreturn a.l>b.l;\n}\n\nbool operator<(dn a, dn b)\n{\n	return b>a;\n}\n\nbool operator==(dn a, dn b)\n{\n	if(a.z==b.z){return a.l==b.l;}\nreturn 0;\n}\n\nbool operator>=(dn a, dn b)\n{\n	return !(b>a);\n}\n\nbool operator<=(dn a, dn b)\n{\n	return !(a>b);\n}\n\nbool operator!=(dn a, dn b)\n{\n	return !(a==b);\n}\n\ndn logc(dn a)\n{\n	dn w;\n	w.l.resize(1, 0);\n	w.l[0]=logcal(w.l);\n	w.z=a.z;\nreturn w;\n}\n\nvoid factorial(dn &a)\n{\n	vector<int> w=a.l, d(1), c(1);\n	if(a.z==0 || !(a.m.size()==1 && a.m[0]==1)){Error3=1;return;}\n	a.l.resize(1,0);\n	a.l[0]=1;\n	c[0]=1;\n	d[0]=1;\n	while(d<=w)\n	{\n		fft_fast(a.l,d);\n		d+=c;\n	}\n}\n\nbool isnERR()\n{\n	if(Error0){cout << \"Cannot divide by zero!\\n\";Error0=0;Error1=0;Error2=0;Error3=0;return 0;}\n	if(Error1){cout << \"Modulus division is only defined for integers\\n\";Error0=0;Error1=0;Error2=0;Error3=0;return 0;}\n	if(Error2){cout << \"In this version (2.4) power is only defined for integers!\\n\";Error0=0;Error1=0;Error2=0;Error3=0;return 0;}\n	if(Error3){cout << \"Factorial is only defined for natural numbers!\\n\";Error0=0;Error1=0;Error2=0;Error3=0;return 0;}\nreturn 1;\n}\n\n",
			"ain",
			"cmake_check_build_system",
			"lib",
			"spis",
			"include",
			".o",
			"Linux/",
			"trol_mix",
			"2.",
			"fft_fast",
			"m;/",
			"m",
			"fft_fast",
			"gedit",
			"wine",
			"cout",
			"err"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			""
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "Makefile",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 918,
						"regions":
						{
						},
						"selection":
						[
							[
								294,
								294
							]
						],
						"settings":
						{
							"syntax": "Packages/Makefile/Makefile.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "hoff.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2931,
						"regions":
						{
						},
						"selection":
						[
							[
								347,
								347
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 204.0,
						"zoom_level": 1.0
					},
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 34.0
	},
	"input":
	{
		"height": 33.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 112.0
	},
	"project": "Calc.sublime-project",
	"replace":
	{
		"height": 64.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 150.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
